/*
 * Telnet.c
 * Autogenerated code from TrainFramework
 *  Created on: {{ date }}
 *      Author: AL
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "core-train.h"
#include "core-routes.h"
#include "core-utils.h"

#include "json.h"
#include "tcp.h"
#include "http.h"
#include "RestFullController.h"

#define ERROR_CODE	"{\"error\":\"%s receive %d parameter(s) instead of %d\"}\r\n%s"
#define EQUAL(command,data)	(strstr(data,command))
#define ARGS_CHECK(v,c)	((c)<2)

#define {{ module['debug.level']  }}
#ifdef DEBUG_TRACE
	#define TRACE(trace)	do{\
								trace;\
							}while(0)
#else
	#define TRACE(trace)
#endif

#define HEADER_ERR_404	"HTTP/1.0 404 PAGE NOT FOUND\r\n\r\n"

#define HEADER_OK_JSON	"HTTP/1.0 200 OK\r\n"\
						"Content-Length: %d\r\n"\
						"Content-Type: application/json; charset=utf-8\r\n\r\n"

#define HEADER_OK_TEXT	"HTTP/1.0 200 OK\r\n"\
						"Content-Type: text/html; charset=utf-8\r\n"\
						"Content-Length: %d\r\n"\
						"Content-Encoding: gzip\r\n\r\n"

char httpBufRx[{{ module['buffer.rx'] }}];
char httpBufTx[{{ module['buffer.tx'] }}];

static char *argv[32];
static uint8_t argc;


int getAttachFile(RailHttp_st *http, RailTcp_st *tcp){
	if(tcp->socket->stream){

	}
	else{
		uint8_t *files[32];
		uint8_t c=0;
		TRACE(printf("\tinput\n%.10s\n...\n",http->attach));
		restParser(
			http->attach,
			httpBufRx,
			sizeof(httpBufRx),
			"filename",
			"\"",
			&files[0],
			&c,
			3
		);
		if(!files[1]){
			TRACE(printf("\tattach file name not found\n"));
			return EXIT_FAILURE;
		}
		http->attachFileName = files[1];
		TRACE(printf("\tattach file name %s\n",http->attachFileName));
		restParser(
				files[2],
				httpBufRx,
				sizeof(httpBufRx),
				"Content-Type",
				" \r\n",
				&files[0],
				&c,
				2
			);
		http->contentType = files[1];
		if(!files[1]){
			TRACE(printf("\tattach file content not found\n"));
			return EXIT_FAILURE;
		}
		TRACE(printf("\tattach file content type %s\n",http->contentType));
		http->attach = files[2]+3;//+2 = move on " \r\n"
		if(!files[2]){
			TRACE(printf("\tattach file not found\n"));
			return EXIT_FAILURE;
		}
		TRACE(printf("\tattach file\n%.10s\n...\n",http->attach));
	}
	char *end=http->attach;
	while(memcmp(end,"\r\n------WebKitFormBoundary",strlen("\r\n------WebKitFormBoundary"))){
		end++;
		if( end>(tcp->packet->data+tcp->requestLen) ){
			TRACE(printf("\tfile end not found\n"));
			end = NULL;
			break;
		}
	}
	if(end){
		tcp->socket->stream = 0;
		http->isStreamEnd = 1;
		http->attachLen = end-(char*)http->attach;
	}
	else{
		http->attachLen = tcp->requestLen-(http->attach-tcp->packet->data);
	}
	TRACE(printf("\tattach file len %d\n",http->attachLen));
	return EXIT_SUCCESS;
}

Parcel_st {{ module['station.parcel'] }}[{{ module['station.parcels'] }}];
Train_st {{ module['station.train'] }};
void {{ module['station.name'] }}Init(void){
	fillDepot(&{{ module['station.train'] }});
	{{ module['station.train'] }}.box = malloc(sizeof(Parcel_st*)*{{ module['station.parcels'] }});
	for(uint16_t iParcel=0;iParcel<{{ module['station.parcels'] }};iParcel++){
		{{ module['station.train'] }}.box[iParcel] = (Parcel_st*)&{{ module['station.parcel'] }}[iParcel];
	}
	{{ module['station.train'] }}.capacity = {{ module['station.parcels'] }};
	{{ module['station.train'] }}.route = {{ module['station.route'] }};
}

int {{ module['station.name'] }}(void *p){
	uint16_t iBox = meetTrainBox(&{{module['station.train'] }},0);
	Parcel_st *box = {{module['station.train'] }}.box[iBox];
	while(box){
		{# the train arrives #}

		if(iBox>{{module['station.train'] }}.capacity) return EXIT_SUCCESS;

		{# get the car from the train #}
		static void *car;
		car = box->parcel;

		enum Type{get=0,post,put,patch,delete};
		enum Type type = get;
		RailTcp_st *railTcp = ((RailTcp_st *)car);
		{# parse packet data and get http command (GET,POST,PUT,PATCH,DELETE) and arguments (URL) #}
		if(railTcp->socket->stream==post){
		}
		else if(EQUAL("GET",(char*)((RailTcp_st*)car)->packet->data)){
			restParser(
				(char*)((RailTcp_st*)car)->packet->data,
				httpBufRx,
				sizeof(httpBufRx),
				"GET",
				" ",
				&argv[0],
				&argc,
				2
			);
			type=get;
		}
		else if(EQUAL("POST",(char*)((RailTcp_st*)car)->packet->data)){
			restParser(
				(char*)((RailTcp_st*)car)->packet->data,
				httpBufRx,
				sizeof(httpBufRx),
				"POST",
				" ",
				&argv[0],
				&argc,
				2
			);
			type=post;
		}
		else if(EQUAL("PUT",(char*)((RailTcp_st*)car)->packet->data)){
			restParser(
				(char*)((RailTcp_st*)car)->packet->data,
				httpBufRx,
				sizeof(httpBufRx),
				"PUT",
				" ",
				&argv[0],
				&argc,
				2
			);
			type=put;
		}
		else if(EQUAL("PATCH",(char*)((RailTcp_st*)car)->packet->data)){
			restParser(
				(char*)((RailTcp_st*)car)->packet->data,
				httpBufRx,
				sizeof(httpBufRx),
				"PATCH",
				" ",
				&argv[0],
				&argc,
				2
			);
			type=patch;
		}
		else if(EQUAL("DELETE",(char*)((RailTcp_st*)car)->packet->data)){
			restParser(
				(char*)((RailTcp_st*)car)->packet->data,
				httpBufRx,
				sizeof(httpBufRx),
				"DELETE",
				" ",
				&argv[0],
				&argc,
				2
			);
			type=delete;
		}

		TRACE(printf("HTTP request \n\t%s with \n\t%d arqument(s)\n",argv[0],argc););
		char *body = argv[2];
		{# parse URL #}
		restParser(
			argv[1],
			httpBufRx,
			sizeof(httpBufRx),
			"/",
			"/",
			&argv[0],
			&argc,
			6
		);

		TRACE(printf("\t%s with \n\t%d arqument(s)\n",argv[0],argc););
		//dummy if
		if(0){}

		{% for gets in module['get'] %}
		else if(EQUAL({{ gets['from.path'] }},argv[0]) && type=={{ gets['from.type'] }}){
			TRACE(printf("HTTP {{ gets['from.path'] }} request\n"););
			{# create parcel - variable to save result #}
			static {{ module['station.railType'] }} {{ module['station.railName'] }}_{{ loop.index0 }};

			{{ module['station.railName'] }}_{{ loop.index0 }}.argv = &argv[1];
			{{ module['station.railName'] }}_{{ loop.index0 }}.argc = argc;
			{{ module['station.railName'] }}_{{ loop.index0 }}.response = httpBufTx;
			{{ module['station.railName'] }}_{{ loop.index0 }}.respBufLen = sizeof(httpBufTx);
			{{ module['station.railName'] }}_{{ loop.index0 }}.respOk = HEADER_OK_TEXT;
			{{ module['station.railName'] }}_{{ loop.index0 }}.respErr = HEADER_ERR_404;
			{{ module['station.railName'] }}_{{ loop.index0 }}.command = {{ gets['to.command'] }};
			{%- if gets['from.loader'] is not none -%}
			{{ module['station.railName'] }}_{{ loop.index0 }}.attach = body;
			if({{ gets['from.loader'] }}(&{{ module['station.railName'] }}_{{ loop.index0 }},railTcp)!=EXIT_SUCCESS) return EXIT_SUCCESS;
			{% endif %}
			railTcp->car = &{{ module['station.railName'] }}_{{ loop.index0 }};
			{{ gets['to.loader'] }}({{ module['station.route'] }},{{ gets['to.route'] }},box->parcel);

		}
		{% endfor %}
		railTcp->socket->stream = type;

		iBox = meetTrainBox(&{{module['station.train'] }},iBox);
		box = {{module['station.train'] }}.box[iBox];
	}

	return EXIT_SUCCESS;
}
