/*
 * udp.c
 * Autogenerated code from TrainFramework
 *
 *  Created on: {{ date }}
 *      Author: AL
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "core-train.h"
#include "core-routes.h"
#include "core-utils.h"

#include "udp.h"
#include "json.h"
#include "files.h"
#include "snmp.h"

#ifdef WIN32
#include 	<windows.h>
#include	<winsock2.h>
#include 	<ws2tcpip.h>
#endif

#define {{ module.debug.level  }}
#ifdef DEBUG_TRACE
	#define TRACE(trace)	do{\
								trace;\
							}while(0)
#else
	#define TRACE(trace)
#endif


int initUdp(void){
	#ifdef WIN32
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2,2),&wsa) != 0){
		printf("Failed. Error Code : %d\n",WSAGetLastError());
		return EXIT_FAILURE;
	}
	#endif
	return EXIT_SUCCESS;
}


int initUdpClient(uint32_t inetAddress,uint16_t port, uint8_t protocol){
	#ifdef WIN32
	// Create a SOCKET for connecting to server
	struct sockaddr_in service;
	service.sin_family = AF_INET;
	service.sin_addr.s_addr = inetAddress;
	service.sin_port = htons(port);
	//create socket
	static SOCKET udpConnectSocket=INVALID_SOCKET;
	udpConnectSocket=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (udpConnectSocket == INVALID_SOCKET) {
		printf("Error at socket(): %d\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}

	int i=1;
	setsockopt(udpConnectSocket,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof (i));
	//bind socket
	if(bind(udpConnectSocket, (SOCKADDR *) &service, sizeof (service))== SOCKET_ERROR){
		printf("bind failed with error %u\n", WSAGetLastError());
		return INVALID_SOCKET;
	}

	#endif
	return udpConnectSocket;
}


Parcel_st {{ module.station.parcel }}[{{ module.station.parcels }}];
Train_st {{ module.station.train }};
void {{ module.station.name }}Init(void){
	fillDepot(&{{ module.station.train }});
	{{ module.station.train }}.box = malloc(sizeof(Parcel_st*)*{{ module.station.parcels }});
	for(uint16_t iParcel=0;iParcel<{{ module.station.parcels }};iParcel++){
		{{ module.station.train }}.box[iParcel] = (Parcel_st*)&{{ module.station.parcel }}[iParcel];
	}
	{{ module.station.train }}.capacity = {{ module.station.parcels }};
	{{ module.station.train }}.route = {{ module.station.route }};
}

/*
 * TCP Railway Station
 */
int {{ module.station.name }}(void *p){
	//Parcel_st *box = meetTrain(&{{module.station.train }});
	uint16_t iBox = meetTrainBox(&{{module.station.train }},0);
	Parcel_st *box = {{module.station.train }}.box[iBox];
	while(box){
		if(iBox>{{module.station.train }}.capacity) return EXIT_SUCCESS;
		printf("\nTCP Station\n");
		printf("\t%p %d %p\n",box,iBox,&{{ module.station.parcel }}[iBox]);
		static void *car;
		car = box->parcel;

		try((car),"\tempty car on tcp train",EXIT_FAILURE);
		int socket = 0;
		try(( (({{ module.station.railType }}*)car)->socket ),"\tInvalid socket",EXIT_FAILURE);
		socket = (({{ module.station.railType }}*)car)->socket;
		uint8_t i=0,slen;
		struct sockaddr_in* sadr;
		while(car){
			TRACE(printf("\tCar number %d command (Hitch_st) %I64u\n",i,((Hitch_st *)car)->command););
			if((0 == i) & ( 0 == ((RailUdp_st *)car)->command )){
				sadr = ((RailUdp_st *)car)->saddr;
				slen = ((RailUdp_st *)car)->slen;
			}
			{% for path in module.pathways %}

			else if( ({{  path.from.carNumber }} == i) & ( {{ path.from.command }} == (({{ path.from.railType }} *)car)->command ) ){
				TRACE(printf("\t{{ path.from.command }} load\n"););
				{# get the parcel from the car #}
				{{ path.from.railType }} *{{ path.from.railName }} = (({{ path.from.railType }} *)car);
				{# create the car for the hitch with the train #}
				static {{ module.station.railType }} {{ module.station.railName }}_{{ loop.index0 }}={NULL};
				try( ({{ path.from.railName }}), "\tthe rails {{ path.from.railType }} do not go to {{  module.station.name }}\n", EXIT_FAILURE );
				{# load the parcel from the train #}
				{% if path.from.loader %}
				{{ module.station.railName }}_{{ loop.index0 }}.response = (uint8_t*){{ path.from.railName }}->response;
				{{ module.station.railName }}_{{ loop.index0 }}.respLen = {{ path.from.railName }}->respLen;
				TRACE(printf("\tSend response:\n\t\t%d bytes\n\t\t%s\n",{{ module.station.railName }}_{{ loop.index0 }}.respLen,{{ module.station.railName }}_{{ loop.index0 }}.response););
				for(int l=0;l<{{ module.station.railName }}_{{ loop.index0 }}.respLen;l++){
					TRACE(printf("0x%02X ",{{ module.station.railName }}_{{ loop.index0 }}.response[l]););
				}
				TRACE(printf("\n"););
				{% else %}
				{% endif %}


				{# select loader for new train #}
				{% if path.to.loader=='sendto' -%}
				/*
				 * send response to TCP client or
				 * send request to TCP server
				 */
				try( (socket), "\tthe rails {{ path.from.railType }} do not go to {{  module.station.name }}\n", EXIT_FAILURE );
				TRACE(printf("\t\tTo %s:%d\n\n",inet_ntoa(sadr->sin_addr), ntohs(sadr->sin_port)););
				{{ path.to.loader }}(
					socket,
					(char*){{ module.station.railName }}_{{ loop.index0 }}.response,
					{{ module.station.railName }}_{{ loop.index0 }}.respLen,
					0,
					(struct sockaddr*)sadr,
					slen
				);
				{% else %}
				/*
				 * send message to TCP observers
				 * example  railTcp->to_port=80 send message to ROUTE_HTTP
				 */
				{{ path.from.railName }}->car = &{{ module.station.railName }}_{{ loop.index0 }};
				{{ path.to.loader }}({{ module.station.route }},{{ path.to.route }},box->parcel);
				{% endif %}
				(({{ path.from.railType }} *)car)->command = 0;
			}

			{% endfor %}

			car = ((Hitch_st*)car)->car;
			i++;
		}

		//box=meetTrain(&{{module.station.train }});
		iBox = meetTrainBox(&{{module.station.train }},iBox);
		box = {{module.station.train }}.box[iBox];
	}
	return EXIT_SUCCESS;
}
