/*
 * pb.c
 * Autogenerated code from TrainFramework
 *
 *  Created on: {{ date }}
 *      Author: home
 */


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "core-train.h"
#include "core-routes.h"
#include "core-utils.h"

#include "database.h"
#include "pb.h"
#include "telnet.h"

#define {{ module['debug.level']  }}
#ifdef DEBUG_TRACE
	#define TRACE(trace)	do{\
								trace;\
							}while(0)
#else
	#define TRACE(trace)
#endif

#ifdef WIN32
#include<windows.h>
#endif
/*
 * read database table and write as object to buf
 * char *buf pointer to result buffer
 * uint32_t bufLenMax buf size
 * DbTable_st *table pointer to database table
 */
int extractTableAsPbToBuf(char *buf,uint32_t bufLenMax,DbTable_st *table){

	char *pBuf=buf;
	int len = bufLenMax;

	pBuf += snprintf(
		pBuf
		,len
		,"\"%.*s\":{"
		,strConfigLen(table->primary_index)
		,table->primary_index
	);
	len = bufLenMax-(uint32_t)(pBuf-buf);
	try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);

	LinkedList_st *parameter = table->parameters;
	while(parameter){
		uint8_t keyLen = strConfigLen(parameter->key);
		uint8_t valLen = strConfigLen(parameter->value);
		try( ((len-(keyLen+valLen+6))>0),"\n!EXIT_NEED_MORE_MEMORY!\n",-1);

		/*
		 * FIXME: change to Protobuf
		 */
		/*
		pBuf += snprintf(
			pBuf
			,len
			,"\"%.*s\":\"%.*s\","
			,keyLen
			,parameter->key
			,valLen
			,parameter->value
		);
		len = bufLenMax-(uint32_t)(pBuf-buf);
		try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);
		*/

		parameter = parameter->next;
	}
	pBuf--;
	pBuf += snprintf(
		pBuf
		,len
		,"},"
	);
	len = bufLenMax-(uint32_t)(pBuf-buf);
	try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);

	*pBuf = '\0';
	#ifdef DEBUG_TRACE
		printf("table %s\n",buf);
	#endif
	return (int)(pBuf-buf);
}

/*
 * read database tables and write as object to buf
 * char *buf pointer to result buffer
 * uint32_t bufLenMax buf size
 * char *table array of pointers to database tables
 * uint16_t iTables number of tables
 */
int extractTablesAsPbToBuf(char *buf,uint32_t bufLenMax,char *tables[], uint16_t iTables){

	char *pBuf=buf;
	int len = bufLenMax;
	for(uint16_t i=0;i<iTables;i++){
		DbTable_st *table = (DbTable_st *)tables[i];
		pBuf += snprintf(
			pBuf
			,len
			,"\"%.*s\":{"
			,strConfigLen(table->primary_index)
			,table->primary_index
		);
		len = bufLenMax-(uint32_t)(pBuf-buf);
		try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);

		LinkedList_st *parameter = table->parameters;
		while(parameter){
			uint8_t keyLen = strConfigLen(parameter->key);
			uint8_t valLen = strConfigLen(parameter->value);
			try( ((len-(keyLen+valLen+6))>0),"\n!EXIT_NEED_MORE_MEMORY!\n",-1);
			/*
			 * FIXME: change to Protobuf
			 */
			/*
			pBuf += snprintf(
				pBuf
				,len
				,"\"%.*s\":\"%.*s\","
				,keyLen
				,parameter->key
				,valLen
				,parameter->value
			);
			len = bufLenMax-(uint32_t)(pBuf-buf);
			try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);
			*/

			parameter = parameter->next;
		}
		pBuf--;
		pBuf += snprintf(
			pBuf
			,len
			,"},"
		);
		len = bufLenMax-(uint32_t)(pBuf-buf);
		try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);

		*pBuf = '\0';
		#ifdef DEBUG_TRACE
			printf("table %s\n",buf);
		#endif
	}
	return (int)(pBuf-buf);
}

/*
 * read database tables and write as object to buf
 * char *buf pointer to result buffer
 * uint32_t bufLenMax buf size
 * char *table array of pointers to database tables
 * uint16_t iTables number of tables
 */
int extractValuesAsPbToBuf(char *buf,uint32_t bufLenMax,char *values[], uint16_t iValues){

	char *pBuf=buf;
	int len = bufLenMax;

	pBuf += snprintf(
		pBuf
		,len
		,"["
	);
	len = bufLenMax-(uint32_t)(pBuf-buf);
	try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);

	for(uint16_t i=0;i<iValues;i++){
		/*
		 * FIXME: change to Protobuf
		 */
		/*
		pBuf += snprintf(
			pBuf
			,len
			,"%.*s,"
			,strConfigLen(values[i])
			,values[i]
		);
		len = bufLenMax-(uint32_t)(pBuf-buf);
		try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);
		*/
	}
	pBuf--;
	pBuf += snprintf(
		pBuf
		,len
		,"]"
	);
	len = bufLenMax-(uint32_t)(pBuf-buf);
	try( ((bufLenMax-len)>0),"EXIT_NEED_MORE_MEMORY",-1);

	*pBuf = '\0';
	#ifdef DEBUG_TRACE
		printf("values: %s\n",buf);
	#endif
	return (int)(pBuf-buf);
}
/*
 * read database tables and write as JSON object to buf
 * char *buf pointer to result buffer
 * uint32_t bufLenMax buf size
 * DbTable_st *table pointer to database
 */
int printDbAsPbToBuf(char *buf,uint32_t bufLenMax,DbTable_st *db){

	char *pBuf=buf;
	int len = bufLenMax;

	#ifdef DEBUG_TRACE
		printf("JSON start parce database table to buffer %p %d %p\n",buf,bufLenMax,db);
	#endif

	/*
	 * FIXME: change to Protobuf
	 */
	/*
	pBuf += snprintf(
		pBuf
		,len
		,"{"
	);
	len = bufLenMax-(uint32_t)(pBuf-buf);
	try( (bufLenMax-len),"EXIT_NEED_MORE_MEMORY",EXIT_NEED_MORE_MEMORY);

	while(db){
		try( ( (len=(bufLenMax-extractTableAsJsonToBuf(pBuf,len,db)))>0 ) ,"\nDB parcer to JSON error\n",EXIT_NEED_MORE_MEMORY);
		pBuf += (bufLenMax-len);
		db = db->next;
	}
	pBuf--;
	pBuf += snprintf(
		pBuf
		,len
		,"}"
	);
	*pBuf = '\0';
	*/
	#ifdef DEBUG_TRACE
		printf("JSON database '%s'\n",buf);
	#endif
	return EXIT_SUCCESS;
}

/*
 * read database table and write as JSON object to buf
 * char *buf pointer to result buffer
 * uint32_t bufLenMax buf size
 * DbTable_st *table pointer to database table
 */
int printTableAsPbToBuf(char *buf,uint32_t bufLenMax,DbTable_st *table){

	char *pBuf=buf;
	int len = bufLenMax;

	/*
	 * FIXME: change to Protobuf
	 */
	/*
	pBuf += snprintf(
		pBuf
		,len
		,"{"
	);
	len = bufLenMax-(uint32_t)(pBuf-buf);
	try( (bufLenMax-len),"EXIT_NEED_MORE_MEMORY",EXIT_NEED_MORE_MEMORY);

	try( ( (len=(bufLenMax-extractTableAsJsonToBuf(pBuf,len,table)))>0 ) ,"\nDB parcer to JSON error\n",EXIT_NEED_MORE_MEMORY);
	pBuf += (bufLenMax-len-1);

	pBuf += snprintf(
		pBuf
		,len
		,"}"
	);
	*pBuf = '\0';
	*/
	#ifdef DEBUG_TRACE
		printf("JSON table '%s'\n",buf);
	#endif
	return EXIT_SUCCESS;
}



/*
 * find table in database with name, key and value
 * if parameter equal '*' - find all
 * char **result array of pointers to return results
 * uint32_t resultLenMax size of array result
 * DbTable_st *db database
 * char* name primary key
 * char *key parameter
 * char *value
 */
int findTablesWithKeyValue(char **argv,uint32_t resultLenMax,uint16_t* argc,DbTable_st *db,char* name,char *key, char *value){
	try( (db),"Database is null",EXIT_FAILURE);
	#ifdef DEBUG_TRACE
		printf("JSON search tables %s where key %s = %s in %p\n",name,key,value,db);
	#endif
	uint16_t nameSize = strlen(name);
	uint16_t keySize = strlen(key);
	uint16_t valueSize = strlen(value);
	DbTable_st *table = db;
	while(table){
		if( !equals(name,"*",1) || !equals(table->primary_index, name,nameSize)){
			LinkedList_st *parameter = table->parameters;
			while(parameter){
				if(  !equals(key,"*",1) || !equals(parameter->key,key,keySize)){
					if( !equals(value,"*",1) || !equals(parameter->value,value,valueSize)){
						#ifdef DEBUG_TRACE
							printf("Find \n\t%.1s \t%.1s \t%.1s \n",table->primary_index,parameter->key,parameter->value);
						#endif
						argv[*argc] = (char*)table;
						*argc += 1;
						break;
					}
				}
				parameter = parameter->next;
			}
		}
		if( (*argc)>resultLenMax ){
			printf("findTablesWithKeyValue error: (*argc)>resultLenMax");
			return EXIT_FAILURE;
		}
		table = table->next;
	}
	return EXIT_SUCCESS;
}

int findValues(char **argv,uint32_t resultLenMax,uint16_t* argc,DbTable_st *db,char* name,char *key, char *value){
	try( (db),"Database is null",EXIT_FAILURE);
	#ifdef DEBUG_TRACE
		printf("JSON search values %s where key %s = %s in %p\n",name,key,value,db);
	#endif
	uint16_t nameSize = strlen(name);
	uint16_t keySize = strlen(key);
	uint16_t valueSize = strlen(value);
	DbTable_st *table = db;
	while(table){
		if( !equals(name,"*",1) || !equals(table->primary_index, name,nameSize)){
			LinkedList_st *parameter = table->parameters;
			while(parameter){
				if(  !equals(key,"*",1) || !equals(parameter->key,key,keySize)){
					if( !equals(value,"*",1) || !equals(parameter->value,value,valueSize)){
						#ifdef DEBUG_TRACE
							printf("Find \n\t%.1s \t%.1s \t%.1s \n",table->primary_index,parameter->key,parameter->value);
						#endif
						argv[*argc] = parameter->value;
						*argc += 1;
						break;
					}
				}
				parameter = parameter->next;
			}
		}
		if( (*argc)>resultLenMax ){
			printf("findTablesWithKeyValue error: (*argc)>resultLenMax");
			return EXIT_FAILURE;
		}
		table = table->next;
	}
	return EXIT_SUCCESS;
}


int jsonGet(RailTelnet_st *rail){
	#ifdef DEBUG_TRACE
	printf("\tjsonGet\n");
	#endif
	char *tables[32];
	uint16_t iTables = 0;
	tables[0] = NULL;
	findTablesWithKeyValue(&tables[0],32,&iTables,getDbInstance(),rail->argv[1],rail->argv[2],rail->argv[3]);
	if(tables[0]){
		rail->respLen = extractTablesAsJsonToBuf(rail->respBuf,rail->respBufLen,tables,iTables);
		rail->respLen +=
			snprintf(
				rail->respBuf+rail->respLen,
				rail->respBufLen-rail->respLen,
				"\r\n%s",
				rail->respOk
			);
	}
	else{
		rail->respLen =
			snprintf(
				rail->respBuf,
				rail->respBufLen,
				"\r%s",
				rail->respErr
			);
	}
	return EXIT_SUCCESS;
}

int jsonGetv(RailTelnet_st *rail){
	#ifdef DEBUG_TRACE
	printf("\tjsonGetv\n");
	#endif
	char *tables[32];
	uint16_t iTables = 0;
	tables[0] = NULL;
	findTablesWithKeyValue(&tables[0],32,&iTables,getDbInstance(),rail->argv[1],rail->argv[2],rail->argv[3]);
	if(tables[0]){
		rail->respLen = extractTablesAsJsonToBuf(rail->respBuf,rail->respBufLen,tables,iTables);
		rail->respLen +=
			snprintf(
				rail->respBuf+rail->respLen,
				rail->respBufLen-rail->respLen,
				"\r\n%s",
				rail->respOk
			);
	}
	else{
		rail->respLen =
			snprintf(
				rail->respBuf,
				rail->respBufLen,
				"\r%s",
				rail->respErr
			);
	}
	return EXIT_SUCCESS;
}

int jsonPut(RailTelnet_st *rail){
	#ifdef DEBUG_TRACE
	printf("\tjsonPut\n");
	#endif
	char *values[32];
	uint16_t iValues = 0;
	values[0] = NULL;
	findValues(&values[0],32,&iValues,getDbInstance(),rail->argv[1],rail->argv[2],"*");
	if(values[0]){
		for(int i=0;i<iValues;i++){
			TRACE(printf("put \tlen_n \tlen_old: \n%s\t%d\t%d\n",rail->argv[3],strlen(rail->argv[3]),strConfigLen(values[i])););
			snprintf(values[i],strConfigLen(values[i])+1,"%s",rail->argv[3]);
		}


		rail->respLen = extractValuesAsJsonToBuf(rail->respBuf,rail->respBufLen,values,iValues);
		rail->respLen +=
			snprintf(
				rail->respBuf+rail->respLen,
				rail->respBufLen-rail->respLen,
				"\r\n%s",
				rail->respOk
			);
	}
	else{
		rail->respLen =
			snprintf(
				rail->respBuf,
				rail->respBufLen,
				"\r%s",
				rail->respErr
			);
	}
	return EXIT_SUCCESS;
}

Parcel_st {{ module['station.parcel'] }}[{{ module['station.parcels'] }}];
Train_st {{ module['station.train'] }};
//{{ module['station.railType'] }} {{ module['station.railName'] }}={NULL};
void {{ module['station.name'] }}Init(void){
	//{{ module['station.railName'] }}.table = getDbInstance();

	fillDepot(&{{ module['station.train'] }});
	{{ module['station.train'] }}.box = malloc(sizeof(Parcel_st));
	{{ module['station.train'] }}.box[0] = (Parcel_st*)&{{ module['station.parcel'] }};
	{{ module['station.train'] }}.capacity = {{ module['station.parcels'] }};
	{{ module['station.train'] }}.route = {{ module['station.route'] }};
}

/*
 * build a railway to Json
 */
//extern Train_st jsonTrain;
int {{  module['station.name'] }}(void *p){
	#ifdef WIN32
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
	WORD saved_attributes;

	/* Save current attributes */
	GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
	saved_attributes = consoleInfo.wAttributes;
	#endif

	//the train arrives
	Parcel_st *box=meetTrain(&{{ module['station.train'] }});
	while(box){

		static void *car;
		car = box->parcel;

		for(uint8_t iHitch=0;iHitch<({{  module['station.carNumber'] }}-1);iHitch++){
			{# get the car from the train #}
			car = ((Hitch_st*)car)->car;
		}

		if(car==NULL) return EXIT_FAILURE;


		{% for path in module['pathways'] %}

		else if( {{ path['from.command'] }} == (({{ path['from.railType'] }} *)car)->command ){
			/*
			car = box->parcel;
			for(uint8_t iHitch;iHitch<({{  module['station.carNumber'] }}-1);iHitch++){
				{# get the car from the train #}
				car = ((Hitch_st*)car)->car;
			}
			*/

			{# get the parcel from the car #}
			{{ path['from.railType'] }} *{{ path['from.railName'] }} = (({{ path['from.railType'] }} *)car);

			{# create the car for the hitch with the train #}
			static {{ module['station.railType'] }} {{ module['station.railName'] }}_{{ loop.index0 }};


			try( ({{ path['from.railName'] }}), "the rails {{ path['from.railType'] }} do not go to {{  module['station.name'] }}\n", EXIT_FAILURE );
			{{ path['from.loader'] }}({{ path['from.railName'] }});

			{{ path['from.railName'] }}->car = &{{ module['station.railName'] }}_{{ loop.index0 }};
			{{ path['from.railName'] }}->command = {{ path['to.command'] }};
			{{ path['to.loader'] }}({{ module['station.route'] }},{{ path['to.route'] }},box->parcel);
			//(({{ path['from.railType'] }} *)car)->command = 0;
		}

		{% endfor %}


		else{
			{{ module['defaultPath.to.loader'] }}({{ module['station.route'] }},{{ module['station.routeError'] }},NULL);
		}

		box=meetTrain(&{{ module['station.train'] }});
	}

	return EXIT_SUCCESS;
}
